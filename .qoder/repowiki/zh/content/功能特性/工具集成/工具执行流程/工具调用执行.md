# 工具调用执行

<cite>
**本文档引用的文件**   
- [mcp_manager.js](file://background/managers/mcp_manager.js)
- [mcp_controller.js](file://sandbox/controllers/mcp_controller.js)
- [tool_executor.js](file://background/handlers/session/prompt/tool_executor.js)
- [control_manager.js](file://background/managers/control_manager.js)
- [utils.js](file://background/handlers/session/utils.js)
- [message_handler.js](file://sandbox/controllers/message_handler.js)
- [app_controller.js](file://sandbox/controllers/app_controller.js)
- [prompt.js](file://sandbox/controllers/prompt.js)
</cite>

## 目录
1. [简介](#简介)
2. [工具调用执行流程](#工具调用执行流程)
3. [通信模式分析](#通信模式分析)
4. [请求超时与错误处理](#请求超时与错误处理)
5. [前端服务器选择机制](#前端服务器选择机制)
6. [完整执行序列图](#完整执行序列图)

## 简介
本文档深入解析MCPManager的executeTool方法执行流程，详细说明工具调用的完整生命周期。文档涵盖从用户选择服务器到最终执行工具的全过程，重点分析HTTP和SSE两种通信模式的实现机制，以及前端与后端之间的数据传递流程。

## 工具调用执行流程

MCPManager的executeTool方法是工具调用的核心入口，负责定位目标工具所属的服务器并执行调用。该方法首先通过遍历所有服务器的工具列表来查找指定名称的工具。

```mermaid
flowchart TD
Start([开始执行工具调用]) --> FindServer["遍历所有服务器<br/>查找目标工具"]
FindServer --> ServerFound{"找到服务器?"}
ServerFound --> |是| GetMode["获取服务器通信模式<br/>(HTTP/SSE)"]
ServerFound --> |否| ThrowError["抛出错误<br/>工具未找到"]
GetMode --> IsHttp{"HTTP模式?"}
IsHttp --> |是| SendHttp["调用sendRequestHttp<br/>发送JSON-RPC请求"]
IsHttp --> |否| SendSse["调用sendRequest<br/>发送请求并等待SSE响应"]
SendHttp --> WaitForHttp["等待HTTP响应"]
SendSse --> WaitForSse["通过pendingRequests等待<br/>事件流响应"]
WaitForHttp --> ReturnResult["返回执行结果"]
WaitForSse --> ReturnResult
ThrowError --> ReturnResult
ReturnResult --> End([结束])
```

**图示来源**
- [mcp_manager.js](file://background/managers/mcp_manager.js#L479-L525)

**本节来源**
- [mcp_manager.js](file://background/managers/mcp_manager.js#L479-L525)

## 通信模式分析

MCPManager支持HTTP和SSE两种通信模式，通过isHttpMode方法判断服务器配置的通信类型。两种模式的实现机制有显著差异：

### HTTP模式
在HTTP模式下，系统通过sendRequestHttp方法发送JSON-RPC请求并直接获取响应。该方法使用标准的HTTP POST请求，具有同步响应特性。

```mermaid
sequenceDiagram
participant Client as "客户端"
participant MCPManager as "MCPManager"
participant Server as "服务器"
Client->>MCPManager : executeTool(工具名, 参数)
MCPManager->>MCPManager : isHttpMode(服务器ID)
MCPManager->>MCPManager : sendRequestHttp(服务器ID, 请求)
MCPManager->>Server : POST /api/endpoint
Server-->>MCPManager : HTTP响应
MCPManager-->>Client : 返回执行结果
```

**图示来源**
- [mcp_manager.js](file://background/managers/mcp_manager.js#L229-L260)

### SSE模式
在SSE模式下，系统通过sendRequest方法发送请求，并利用pendingRequests映射等待事件流响应。该模式采用异步通信机制，通过EventSource接收服务器推送的响应。

```mermaid
sequenceDiagram
participant Client as "客户端"
participant MCPManager as "MCPManager"
participant Server as "服务器"
participant EventSource as "EventSource"
Client->>MCPManager : executeTool(工具名, 参数)
MCPManager->>MCPManager : isHttpMode(服务器ID)
MCPManager->>MCPManager : sendRequest(服务器ID, 请求)
MCPManager->>Server : POST /api/endpoint
MCPManager->>MCPManager : 创建Promise并存入pendingRequests
Server->>EventSource : SSE事件流
EventSource->>MCPManager : handleMessage(消息)
MCPManager->>MCPManager : 从pendingRequests获取对应Promise
MCPManager-->>Client : 解析响应并返回结果
```

**图示来源**
- [mcp_manager.js](file://background/managers/mcp_manager.js#L308-L385)

**本节来源**
- [mcp_manager.js](file://background/managers/mcp_manager.js#L218-L260)
- [mcp_manager.js](file://background/managers/mcp_manager.js#L308-L385)

## 请求超时与错误处理

系统实现了完善的请求超时和错误处理机制，确保在异常情况下能够正确响应。

### 超时机制
在SSE模式下，sendRequest方法为每个请求设置10秒的超时时间。超时后会清除pendingRequests中的对应条目并拒绝Promise。

```mermaid
flowchart TD
Start([发送请求]) --> SetTimeout["设置10秒超时定时器"]
SetTimeout --> StoreRequest["将Promise存入pendingRequests"]
StoreRequest --> SendPost["发送POST请求"]
SendPost --> WaitResponse["等待响应"]
WaitResponse --> ResponseReceived{"收到响应?"}
ResponseReceived --> |是| ClearTimeout["清除定时器"]
ResponseReceived --> |否| Timeout{"超时?"}
Timeout --> |是| RejectPromise["拒绝Promise<br/>清除pendingRequests"]
ClearTimeout --> ResolvePromise["解析Promise"]
ResolvePromise --> End([完成])
RejectPromise --> End
```

### 错误处理策略
系统在多个层面实现了错误处理：
1. **网络错误处理**：在fetch请求中捕获网络异常
2. **HTTP状态错误**：检查响应状态码，非200状态抛出错误
3. **JSON解析错误**：捕获JSON解析异常
4. **业务逻辑错误**：处理服务器返回的error字段

```mermaid
flowchart TD
Start([开始请求]) --> TryBlock["try块"]
TryBlock --> SendRequest["发送HTTP请求"]
SendRequest --> CheckStatus{"状态码200?"}
CheckStatus --> |否| ThrowHttpError["抛出HTTP错误"]
CheckStatus --> |是| ParseJson["解析JSON响应"]
ParseJson --> CheckParse{"解析成功?"}
CheckParse --> |否| ThrowParseError["抛出解析错误"]
CheckParse --> |是| CheckBusiness{"响应包含error字段?"}
CheckBusiness --> |是| ThrowBusinessError["抛出业务错误"]
CheckBusiness --> |否| ReturnResult["返回结果"]
CatchBlock["catch块"] --> HandleError["统一错误处理"]
HandleError --> LogError["记录错误日志"]
LogError --> Rethrow["重新抛出错误"]
ThrowHttpError --> Rethrow
ThrowParseError --> Rethrow
ThrowBusinessError --> Rethrow
```

**图示来源**
- [mcp_manager.js](file://background/managers/mcp_manager.js#L248-L257)
- [mcp_manager.js](file://background/managers/mcp_manager.js#L346-L349)

**本节来源**
- [mcp_manager.js](file://background/managers/mcp_manager.js#L229-L260)
- [mcp_manager.js](file://background/managers/mcp_manager.js#L324-L349)

## 前端服务器选择机制

前端通过MCPController的getSelectedMcpIds方法将用户选择的服务器ID传递到执行上下文中，实现完整的工具调用流程。

### 数据传递流程
1. 用户通过UI选择服务器
2. MCPController维护selectedMcpIds集合
3. PromptController调用getSelectedMcpIds获取选中的服务器ID
4. 服务器ID作为mcpIds参数传递给后端

```mermaid
sequenceDiagram
participant User as "用户"
participant UI as "UI界面"
participant MCPController as "MCPController"
participant PromptController as "PromptController"
participant AppController as "AppController"
participant Background as "后台脚本"
User->>UI : 选择MCP服务器
UI->>MCPController : toggleMcpSelection(服务器ID)
MCPController->>MCPController : 更新selectedMcpIds集合
MCPController->>MCPController : 更新UI标签显示
User->>UI : 发送消息
UI->>PromptController : send()
PromptController->>MCPController : getSelectedMcpIds()
MCPController-->>PromptController : 返回服务器ID数组
PromptController->>AppController : executePrompt(参数, mcpIds)
AppController->>Background : sendToBackground(包含mcpIds的payload)
Background->>MCPManager : 执行工具调用
```

### 关键方法分析
- **getSelectedMcpIds**: 返回当前选中的服务器ID数组
- **selectMcp/deselectMcp**: 管理服务器选择状态
- **updateTagsUI**: 更新UI上的服务器标签显示

```mermaid
classDiagram
class MCPController {
-selectedMcpIds : Set~string~
-mcpServers : Object
+getSelectedMcpIds() : string[]
+selectMcp(id : string) : void
+deselectMcp(id : string) : void
+updateTagsUI() : void
+toggleMcpSelection(id : string) : void
}
class PromptController {
+send() : Promise~void~
+executePrompt(text : string, files : File[], options : Object) : Promise~void~
}
MCPController --> PromptController : "被调用"
PromptController --> MCPController : "调用getSelectedMcpIds()"
```

**图示来源**
- [mcp_controller.js](file://sandbox/controllers/mcp_controller.js#L200-L202)
- [prompt.js](file://sandbox/controllers/prompt.js#L30-L32)
- [message_handler.js](file://sandbox/controllers/message_handler.js#L216-L218)

**本节来源**
- [mcp_controller.js](file://sandbox/controllers/mcp_controller.js#L8-L202)
- [prompt.js](file://sandbox/controllers/prompt.js#L27-L32)
- [app_controller.js](file://sandbox/controllers/app_controller.js#L35-L36)

## 完整执行序列图

以下是工具调用的完整执行序列，从用户界面到最终执行的全过程：

```mermaid
sequenceDiagram
participant User as "用户"
participant UI as "UI界面"
participant PromptController as "PromptController"
participant AppController as "AppController"
participant MessageHandler as "MessageHandler"
participant Background as "后台脚本"
participant MCPManager as "MCPManager"
participant ControlManager as "ControlManager"
User->>UI : 选择MCP服务器
UI->>PromptController : send()
PromptController->>MCPController : getSelectedMcpIds()
MCPController-->>PromptController : 返回服务器ID
PromptController->>AppController : executePrompt()
AppController->>Background : sendToBackground(SEND_PROMPT)
Background->>ToolExecutor : executeIfPresent()
ToolExecutor->>ControlManager : execute(工具调用)
ControlManager->>MCPManager : executeTool(工具名, 参数)
MCPManager->>MCPManager : 查找工具所属服务器
MCPManager->>MCPManager : 判断通信模式
alt HTTP模式
MCPManager->>Server : sendRequestHttp()
Server-->>MCPManager : HTTP响应
else SSE模式
MCPManager->>Server : sendRequest()
MCPManager->>MCPManager : 存入pendingRequests
Server->>MCPManager : SSE事件流
MCPManager->>MCPManager : handleMessage()
MCPManager->>MCPManager : 解析响应
end
MCPManager-->>ControlManager : 返回执行结果
ControlManager-->>ToolExecutor : 返回结果
ToolExecutor-->>MessageHandler : 处理执行结果
MessageHandler-->>UI : 更新界面显示
UI-->>User : 显示执行结果
```

**图示来源**
- [mcp_manager.js](file://background/managers/mcp_manager.js#L479-L525)
- [tool_executor.js](file://background/handlers/session/prompt/tool_executor.js#L22-L25)
- [control_manager.js](file://background/managers/control_manager.js#L43-L157)
- [prompt.js](file://sandbox/controllers/prompt.js#L15-L32)

**本节来源**
- [mcp_manager.js](file://background/managers/mcp_manager.js#L479-L525)
- [tool_executor.js](file://background/handlers/session/prompt/tool_executor.js#L9-L47)
- [control_manager.js](file://background/managers/control_manager.js#L43-L157)
- [prompt.js](file://sandbox/controllers/prompt.js#L15-L32)